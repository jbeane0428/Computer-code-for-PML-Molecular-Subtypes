wv.model <- function (data, classlabel, correction = TRUE) {
        # Implementation of weighted voting code from Golub et al., Science, 1999.
        # Adam Gower, 2008

	# INPUT
        # data: matrix or data frame that contains all probesets for weighted voting by rows and training samples by columns.
        # classlabel: vector of binary outputs (0 or 1).
        # correction: flag to use Broad Institute's correction method (see below).
	#
	# OUTPUT
	# A list with two elements:
	#     weights: a vector of weights for each probeset
	#     means:   a vector of means for each probeset across all samples
	#     The elements of both vectors are named according to the probeset names, i.e., the row names of the data matrix 

        y <- lapply(0:1, function (i) {data[,classlabel==i,drop=F]});                           # y[[1]] = class 0 (generally controls); y[[2]] = class 1 (generally cases).
        mu <- sapply(y, apply, 1, mean, na.rm=T, simplify=F);                                   # mean of each probeset across all samples in each class
        sigma <- sapply(y, apply, 1, sd, na.rm=T, simplify=F);                                  # standard deviation of each probeset across all samples in each class
        if (correction) {sigma <- mapply(pmax, sigma, lapply(mu, `*`, 0.2),SIMPLIFY=F)};        # Correction from Broad Institute: sigma = max(sigma, 0.2*mu);
                                                                                                #     i.e., %CV always >= 20% (communicated to me by Jen Beane)
        a <- (mu[[2]] - mu[[1]]) / (sigma[[1]] + sigma[[2]]);					# Compute the weights (signal to noise metric, similar to t statistic)
        g <- (mu[[1]] + mu[[2]]) / 2;								# Compute the means of each probeset across all samples
        return(list(weights=a, means=g));							# Return all computations in a named list
}

predict.wv <- function (model, data) {
        # Implementation of weighted voting code from Golub et al., Science, 1999.
        # Adam Gower, 2008

	# INPUT
        # model: a list with two elements, named weights and means, that contains the weights and means for each probeset as generated by wv.model()
        # data: matrix or data frame that contains all probesets for weighted voting by rows and test samples by columns.
	#       NOTE: the row names of data must be named in the same manner as the weights and means in the model!
	#
	# OUTPUT
	# A list with three elements:
	#     scores:      a vector of weighted voting scores for each sample; negative = class 0, positive = class 1
	#     predictions: a vector of class predictions (0 or 1) for each sample as determined from the sign of the scores vector
	#     strengths:   a vector of prediction strengths for each sample
	
        indices <- match(names(model$means), rownames(data));                                   # Get indices of variables that are in the model
        votes <- model$weights * (data[indices,,drop=F]-model$means);                           # Determine votes: weight * (value - mean); samples now in columns
	
        # Create matrix V with samples by rows and two columns: the sums of all negative and positive weighted votes, respectively
        V <- sapply(c(-1,1), function (s) {                                                     # For each sign (negative or positive),
                 apply(votes, 2, function (x) {                                                 #     for each sample (column in votes matrix),
                         sum(x[which(sign(x)==s)])                                              #         sum votes for that sample by sign
                 })
             });

        scores <- V[,1] + V[,2];                                                                # Calculate scores: sum of negative votes and positive votes
        predictions <- as.numeric(scores > 0);                                                  # Make predictions: score < 0 = class 0; score > 0 = class 1
        strengths <- abs(scores) / (V[,2] - V[,1]);                                             # Prediction strengths: |scores| / sum |votes|
        return(list(scores=scores, predictions=predictions, strengths=strengths));           # Return all computations in a named list
}


